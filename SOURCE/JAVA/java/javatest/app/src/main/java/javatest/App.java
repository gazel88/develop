/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package javatest;

import java.io.Console;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;


public class App {

    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        //System.out.println(new App().getGreeting());
        //new App().solution(new int[][]{{5,3},{11,5},{13,3},{3,5},{6,1},{1,3},{8,6},{7,2},{2,2}});
        System.out.println("answer="+new App().solution(9, new int[][]{{1,3},{2,3},{3,4},{4,5},{4,6},{4,7},{7,8},{7,9}}));
        
        
    }

    int N, min;
    int[][] map;
    int[] vst;
    int dfs(int n){
        vst[n] = 1;
        int child = 1;
        for(int i = 1; i <= N; i++) {
            if(vst[i] == 0 && map[n][i] == 1) {
                int res = dfs(i);
                System.out.println("res="+res); 
                child += res;
            }
        }
        min = Math.min(min, Math.abs(child - (N - child)));
        return child;
    }
    public int solution(int n, int[][] wires) {
        N = n;
        min = n;
        map = new int[n+1][n+1];
        vst = new int[n+1];
        for(int[] wire : wires) {
            int a = wire[0], b = wire[1];
            map[a][b] = map[b][a] = 1;
        }
        dfs(1);
        return min;
    }

    // public int solution(int storey) {
    //     int res = 0;
    //     if(storey > 10){
    //         int self1 = solution(storey / 10);
    //         System.out.println("storey="+storey+"self1="+self1);
    //         int self2 = solution(storey / 10 + 1);
    //         System.out.println("storey="+storey+"self2="+self2);
    //         res = Math.min(storey % 10 + self1, 10 - storey % 10 + self2);
    //         System.out.println("storey="+storey+"s1="+self1+",s2="+self2+", res="+res);

    //     }else{
    //         res = Math.min(storey, 11 - storey);
    //     }
        
    //     return res;
    // }


    // public int solution(int storey) {
    //     int answer = 0;
    //     List<Integer> b_click = new ArrayList<Integer>();
    //     remainCheck(storey, 10, b_click);
    //     answer = b_click.stream().mapToInt(Math::abs).sum();
    //     return answer;
    // }

    // public void remainCheck(int storey, int base, List<Integer> b_click){
    //     if(storey%base != 0){
    //         int needcnt = storey%base > base/2 || (storey%base == base/2 && storey % (base*10) > 5 * base) ? base - (storey%base) : -(storey%base);
    //         storey += needcnt;
    //         b_click.add(needcnt/(base/10));
    //     }
    //     if(storey != 0){
    //         remainCheck(storey, base * 10, b_click);
    //     }
    // }
    

    // public void storesolution(String[] tickets, int roll, int[][] shop, int money){

    //     Map<String, Integer> ticketMap = new HashMap<>();
    //     for (String is : tickets) {
    //         ticketMap.put(is.split(" ")[0], Integer.parseInt(is.split(" ")[1]));
    //     }

    //     int[][] shop_price = new int[shop.length][shop[0].length];
    //     for (int[] is : shop) {
    //         int is_idx = 0;
    //         for (int is2 : is) {
    //             int is2_idx = 0;
    //             shop_price[is_idx][is2_idx] = ticketMap.get(is2+"");
    //         }
    //     }

    //     //ArrayList ticketlist = new ArrayList<>();

    // }


    // public int[][] solution(int[][] nodeinfo) {
    //     int[][] answer = {};
    //     //점들간의 이어진 선 정보 구함
    //     //int[][] connect = {};

    //     //해당 점의 좌표를 x,y로 확인해서 순서확인
    //     LinkedList<int[]> connect = new LinkedList<>();

    //     Search(nodeinfo, 0, connect, 100000);

    //     int[] sort_y = new int[nodeinfo.length];

    //     int top_y_val = 0;
    //     int top_x_idx = 0;
    //     for(int i=0; i< nodeinfo.length;i++){
    //         if(nodeinfo[i][1] > top_y_val){
    //             top_y_val = nodeinfo[i][1];
    //             top_x_idx = i;
    //         }
    //     }
    //     int top_x_val = nodeinfo[top_x_idx][0];
        
    //     return answer;
    // }

    // public void Search(int[][] nodeinfo, int beforeNode, LinkedList<int[]> connect, int before_top_val){
    //     int top_y_val = 0;
    //     int top_level_idx = 0;
    //     for(int i=0; i< nodeinfo.length;i++){
    //         if(nodeinfo[i][1] > top_y_val && nodeinfo[i][1]<before_top_val){
    //             top_y_val = nodeinfo[i][1];
    //             top_level_idx = i;
    //         }
    //     }
    //     if(beforeNode == 0){
    //         Search(nodeinfo, top_level_idx, connect, top_y_val);
    //     }else{
    //         for(int i=0; i< nodeinfo.length;i++){
    //             if(nodeinfo[i][1] == top_y_val){
    //                 int[] new_data = new int[]{beforeNode, i};
    //                 connect.add(new_data);
                    
    //                 if(connect.size() != nodeinfo.length - 1){
    //                     Search(nodeinfo, i, connect, top_y_val);
    //                 }
    //             }
    //         }
    //     }
    // }
}
